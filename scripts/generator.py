"""
Jsonnet Code Generator Module

Generates well-structured Jsonnet code from analyzed dashboard data.
"""

from typing import Any, Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from .analyzer import DashboardAnalysis, PanelInfo


@dataclass
class GeneratorOptions:
    """Options for Jsonnet code generation."""
    indent_size: int = 4
    max_line_length: int = 120
    extract_repeated: bool = True
    create_templates: bool = True
    add_comments: bool = True
    include_imports: bool = True
    template_style: str = "function"  # "function" or "mixin"


class JsonnetGenerator:
    """
    Generates Jsonnet code from analyzed dashboard data.
    """
    
    # Standard Grafana colors
    STANDARD_COLORS = {
        'green': '#73bf69',
        'red': '#f2495c',
        'blue': '#5794f2',
        'orange': '#ff780a',
        'purple': '#b877d9',
        'yellow': '#ffab40',
        'gray': '#8e8e8e',
        'semi-gray': '#8e8e8e',
    }
    
    def __init__(self, options: Optional[GeneratorOptions] = None):
        """
        Initialize the generator.
        
        Args:
            options: Generator options.
        """
        self.options = options or GeneratorOptions()
        self.indent = ' ' * self.options.indent_size
    
    def generate(self, analysis: DashboardAnalysis) -> str:
        """
        Generate Jsonnet code from dashboard analysis.
        
        Args:
            analysis: The dashboard analysis results.
            
        Returns:
            The generated Jsonnet code as a string.
        """
        lines = []
        
        # Add header comment
        if self.options.add_comments:
            lines.append('// Generated by Grafana Dashboard JSON to Jsonnet Transformer')
            lines.append(f'// Source: {analysis.title}')
            lines.append(f'// Generated at: {self._get_timestamp()}')
            lines.append('')
        
        # Generate local variables section
        locals_section = self._generate_locals(analysis)
        if locals_section:
            lines.extend(locals_section)
            lines.append('')
        
        # Generate panel templates
        if self.options.create_templates:
            templates_section = self._generate_templates(analysis)
            if templates_section:
                lines.extend(templates_section)
                lines.append('')
        
        # Generate dashboard definition
        dashboard_section = self._generate_dashboard(analysis)
        lines.extend(dashboard_section)
        
        return '\n'.join(lines)
    
    def _generate_locals(self, analysis: DashboardAnalysis) -> List[str]:
        """Generate local variable declarations."""
        lines = []
        
        # Colors
        colors = self._extract_colors(analysis)
        if colors:
            lines.append('// Common color definitions')
            lines.append('local colors = {')
            for name, value in colors.items():
                lines.append(f'{self.indent}{name}: {self._format_value(value)},')
            lines.append('};')
            lines.append('')
        
        # Thresholds
        thresholds = self._extract_thresholds(analysis)
        if thresholds:
            lines.append('// Threshold configurations')
            for name, value in thresholds.items():
                lines.append(f'local {name} = {self._format_value(value)};')
            lines.append('')
        
        # Data sources
        datasources = self._extract_datasources(analysis)
        if datasources:
            lines.append('// Data source configurations')
            lines.append('local datasources = {')
            for name, value in datasources.items():
                lines.append(f'{self.indent}{name}: {self._format_value(value)},')
            lines.append('};')
            lines.append('')
        
        # Common targets/queries
        common_targets = self._extract_common_targets(analysis)
        if common_targets:
            lines.append('// Common query targets')
            for name, value in common_targets.items():
                lines.append(f'local {name} = {self._format_value(value)};')
            lines.append('')
        
        return lines
    
    def _generate_templates(self, analysis: DashboardAnalysis) -> List[str]:
        """Generate panel template functions."""
        lines = []
        lines.append('// Panel template functions')
        lines.append('')
        
        # Generate template for each panel type
        panel_types = set(p.type for p in analysis.panels)
        
        for panel_type in panel_types:
            template = self._generate_panel_template(panel_type, analysis)
            if template:
                lines.extend(template)
                lines.append('')
        
        return lines
    
    def _generate_panel_template(self, panel_type: str, analysis: DashboardAnalysis) -> Optional[List[str]]:
        """Generate a template function for a specific panel type."""
        panels_of_type = [p for p in analysis.panels if p.type == panel_type]
        
        if len(panels_of_type) < 1:
            return None
        
        lines = []
        func_name = self._get_template_name(panel_type)
        
        # Generate function signature
        params = self._get_template_params(panels_of_type[0])
        
        lines.append(f'local {func_name}({params}) = {{')
        
        # Common properties
        lines.append(f'{self.indent}type: \'{panel_type}\',')
        
        # Add common defaults based on panel type
        defaults = self._get_panel_defaults(panel_type)
        for key, value in defaults.items():
            lines.append(f'{self.indent}{key}: {self._format_value(value)},')
        
        lines.append('};')
        
        return lines
    
    def _generate_dashboard(self, analysis: DashboardAnalysis) -> List[str]:
        """Generate the main dashboard definition."""
        lines = []
        
        lines.append('{')
        lines.append(f'{self.indent}// Dashboard metadata')
        
        # Title
        lines.append(f'{self.indent}title: \'{analysis.title}\',')
        
        # UID
        if analysis.uid:
            lines.append(f'{self.indent}uid: \'{analysis.uid}\',')
        
        # Tags
        if analysis.tags:
            tags_str = ', '.join(f"'{tag}'" for tag in analysis.tags)
            lines.append(f'{self.indent}tags: [{tags_str}],')
        
        # Timezone
        if analysis.timezone:
            lines.append(f'{self.indent}timezone: \'{analysis.timezone}\',')
        
        # Schema version
        lines.append(f'{self.indent}schemaVersion: {analysis.dashboard_config.get("schemaVersion", 38)},')
        
        # Version
        if analysis.dashboard_config.get('version'):
            lines.append(f'{self.indent}version: {analysis.dashboard_config.get("version")},')
        
        # Panels
        lines.append('')
        lines.append(f'{self.indent}// Panels')
        lines.append(f'{self.indent}panels: [')
        
        for i, panel in enumerate(analysis.panels):
            panel_str = self._generate_panel(panel, analysis)
            lines.append(panel_str)
            if i < len(analysis.panels) - 1:
                lines[-1] += ','
        
        lines.append(f'{self.indent}],')
        
        # Time range
        lines.append('')
        lines.append(f'{self.indent}// Time configuration')
        time_cfg = analysis.dashboard_config.get('time', {'from': 'now-6h', 'to': 'now'})
        lines.append(f'{self.indent}time: {self._format_value(time_cfg)},')
        
        # Refresh
        if analysis.dashboard_config.get('refresh'):
            lines.append(f'{self.indent}refresh: \'{analysis.dashboard_config.get("refresh")}\',')
        
        lines.append('}')
        
        return lines
    
    def _generate_panel(self, panel: PanelInfo, analysis: DashboardAnalysis) -> str:
        """Generate a single panel definition."""
        lines = []
        indent = self.indent * 2
        
        lines.append(f'{indent}{{')
        lines.append(f'{indent * 2}// {panel.title}')
        lines.append(f'{indent * 2}id: {panel.panel_id},')
        lines.append(f'{indent * 2}type: \'{panel.type}\',')
        lines.append(f'{indent * 2}title: \'{panel.title}\',')
        
        # Grid position
        grid_pos = panel.grid_pos
        lines.append(f'{indent * 2}gridPos: {{ x: {grid_pos.get("x", 0)}, y: {grid_pos.get("y", 0)}, w: {grid_pos.get("w", 12)}, h: {grid_pos.get("h", 8)} }},')
        
        # Data source
        if panel.datasource:
            lines.append(f'{indent * 2}datasource: {{ type: \'{panel.datasource}\', uid: \'{{{{datasource_uid}}}}\' }},')
        
        # Targets
        if panel.targets:
            lines.append(f'{indent * 2}targets: [')
            for target in panel.targets:
                lines.append(f'{indent * 3}{self._format_value(target)},')
            lines.append(f'{indent * 2}],')
        
        lines.append(f'{indent}}}')
        
        return '\n'.join(lines)
    
    def _extract_colors(self, analysis: DashboardAnalysis) -> Dict[str, str]:
        """Extract common color definitions."""
        colors = {}
        color_map = {
            'green': '#73bf69',
            'red': '#f2495c',
            'blue': '#5794f2',
            'orange': '#ff780a',
        }
        
        # Check for common color usage
        color_usage = {}
        for panel in analysis.panels:
            colors_list = panel.custom_properties.get('colors', [])
            if colors_list:
                color_usage[tuple(colors_list)] = color_usage.get(tuple(colors_list), 0) + 1
        
        # Add standard colors
        colors.update(color_map)
        
        return colors
    
    def _extract_thresholds(self, analysis: DashboardAnalysis) -> Dict[str, Any]:
        """Extract threshold configurations."""
        thresholds = {}
        
        threshold_usage = {}
        for panel in analysis.panels:
            thresh = panel.custom_properties.get('thresholds')
            if thresh:
                thresh_key = str(thresh)
                threshold_usage[thresh_key] = threshold_usage.get(thresh_key, 0) + 1
        
        # Create named thresholds for common patterns
        if threshold_usage:
            thresholds['defaultThresholds'] = {
                'mode': 'absolute',
                'steps': [
                    {'color': 'green', 'value': None},
                    {'color': 'green', 'value': 80},
                    {'color': 'red', 'value': 90},
                ]
            }
        
        return thresholds
    
    def _extract_datasources(self, analysis: DashboardAnalysis) -> Dict[str, Any]:
        """Extract data source configurations."""
        datasources = {}
        
        for ds in analysis.data_sources:
            if ds and ds != '${datasource}':
                datasources[ds] = {
                    'type': ds,
                    'url': f'http://{ds}:9090',
                    'access': 'proxy',
                    'isDefault': False
                }
        
        return datasources
    
    def _extract_common_targets(self, analysis: DashboardAnalysis) -> Dict[str, Any]:
        """Extract common query targets."""
        targets = {}
        
        for i, target in enumerate(analysis.common_targets[:3]):
            target_name = f'query{i + 1}'
            targets[target_name] = target
        
        return targets
    
    def _get_template_name(self, panel_type: str) -> str:
        """Get the template function name for a panel type."""
        # Convert panel type to camelCase function name
        name = panel_type.replace('-', '_').replace(' ', '_')
        return f'{name}Panel'
    
    def _get_template_params(self, panel: PanelInfo) -> str:
        """Get template function parameters."""
        params = ['title', 'gridPos']
        
        if panel.targets:
            params.append('targets')
        
        if panel.datasource:
            params.append('datasource')
        
        return ', '.join(params)
    
    def _get_panel_defaults(self, panel_type: str) -> Dict[str, Any]:
        """Get default values for a panel type."""
        defaults = {
            'transparent': False,
            'gridPos': {'x': 0, 'y': 0, 'w': 12, 'h': 8},
        }
        
        type_specific = {
            'graph': {
                'lines': True,
                'fill': 1,
                'linewidth': 1,
                'pointradius': 2,
                'bars': False,
                'dashLength': 10,
                'spaceLength': 10,
                'percentage': False,
                'legend': {
                    'show': True,
                    'values': False,
                    'min': False,
                    'max': False,
                    'current': False,
                    'total': False,
                    'avg': False,
                },
                'tooltip': {
                    'shared': True,
                    'sort': 0,
                    'include_null': False,
                },
            },
            'timeseries': {
                'transparent': False,
                'lines': True,
                'fillOpacity': 80,
                'gradientMode': 'opacity',
                'showPoints': 'auto',
                'unit': 'short',
            },
            'stat': {
                'transparent': False,
                'colorMode': 'value',
                'graphMode': 'area',
                'justifyMode': 'auto',
                'textMode': 'auto',
                'wideLayout': True,
            },
            'gauge': {
                'transparent': False,
                'min': 0,
                'max': 100,
                'showThresholdLabels': False,
                'showThresholdMarkers': True,
            },
            'table': {
                'transparent': False,
                'sortBy': 'A-Z',
                'showHeader': True,
            },
            'bargauge': {
                'transparent': False,
                'displayMode': 'gradient',
                'valueMode': 'text',
            },
            'piechart': {
                'transparent': False,
                'displayLabels': ['name', 'percent'],
                'pieType': 'pie',
                'legend': {
                    'displayMode': 'list',
                    'placement': 'right',
                    'values': ['value'],
                },
            },
            'heatmap': {
                'transparent': False,
                'cards': {'padding': 1, 'spacing': 1},
                'colorScale': 'spectral',
            },
        }
        
        defaults.update(type_specific.get(panel_type, {}))
        return defaults
    
    def _format_value(self, value: Any) -> str:
        """Format a value for Jsonnet output."""
        if value is None:
            return 'null'
        elif isinstance(value, bool):
            return str(value).lower()
        elif isinstance(value, str):
            # Escape special characters
            escaped = value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n')
            return f'"{escaped}"'
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, list):
            items = [self._format_value(item) for item in value]
            return '[' + ', '.join(items) + ']'
        elif isinstance(value, dict):
            items = []
            for k, v in value.items():
                formatted_value = self._format_value(v)
                items.append(f'{self.indent}{self.indent}{k}: {formatted_value}')
            closing = '}'
            return '{\n' + ',\n'.join(items) + '\n' + self.indent + closing
        else:
            return str(value)
    
    def _get_timestamp(self) -> str:
        """Get current timestamp."""
        from datetime import datetime
        return datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')